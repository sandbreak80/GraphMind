#!/usr/bin/env python3
"""Test Context Compression System"""

import requests
import time
import json
from datetime import datetime

def test_context_compression():
    base_url = "http://localhost:8002"
    
    # Authenticate
    print("üîê Authenticating...")
    response = requests.post(
        f"{base_url}/auth/login",
        data={"username": "admin", "password": "admin123"}
    )
    token = response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}
    print("‚úÖ Authentication successful!")
    
    print("\nüìù TESTING CONTEXT COMPRESSION SYSTEM")
    print("=" * 60)
    
    # Sample long text for compression testing
    sample_texts = [
        {
            "name": "Trading Strategy Guide",
            "text": """
            A comprehensive trading strategy implementation involves multiple critical steps that must be carefully executed to ensure success in the financial markets. The first step is to define clear entry and exit rules based on technical analysis, fundamental analysis, or a combination of both approaches. Entry rules should specify exactly when to enter a position, including the specific conditions, price levels, and technical indicators that trigger a buy signal. Exit rules are equally important and should define when to close a position, whether for profit-taking or loss-cutting purposes. Risk management is the cornerstone of any successful trading strategy. This involves setting appropriate position sizes based on account size and risk tolerance, implementing stop-loss orders to limit potential losses, and diversifying across different assets and timeframes. Never risk more than 2% of your account on a single trade, as this provides protection against significant drawdowns. Backtesting is essential for validating any trading strategy before deploying it with real money. This involves testing the strategy on historical data to assess its performance, identify potential weaknesses, and optimize parameters. A strategy that shows consistent profitability over multiple market conditions is more likely to succeed in live trading. Once backtesting is complete, the strategy should be paper-traded or simulated before going live to ensure it works as expected in real-time conditions. Performance monitoring and continuous optimization are crucial for maintaining strategy effectiveness over time.
            """,
            "expected_compression": 0.3
        },
        {
            "name": "Risk Management Best Practices",
            "text": """
            Risk management is the most critical aspect of successful trading and cannot be overstated. The primary goal of risk management is to preserve capital and ensure long-term survival in the markets. Position sizing is the first line of defense against excessive losses. Never risk more than 1-2% of your total account value on any single trade, regardless of how confident you are in the setup. This rule applies to all traders, from beginners to professionals. Stop-loss orders are essential tools for limiting downside risk and should be placed immediately after entering a position. The stop-loss level should be based on technical analysis, such as support and resistance levels, rather than arbitrary percentages. Diversification across different asset classes, sectors, and timeframes helps reduce overall portfolio risk. A well-diversified portfolio is less likely to experience significant losses from a single market event. Regular portfolio rebalancing ensures that risk exposure remains within acceptable limits as market conditions change. Emotional discipline is crucial for effective risk management. Greed and fear are the two biggest enemies of traders and can lead to poor decision-making. Sticking to predetermined risk parameters and not deviating from the plan is essential for long-term success. Regular performance reviews help identify areas for improvement and ensure that risk management practices remain effective over time.
            """,
            "expected_compression": 0.4
        },
        {
            "name": "Technical Analysis Overview",
            "text": """
            Technical analysis is a method of evaluating securities by analyzing statistics generated by market activity, such as past prices and volume. This approach assumes that market prices reflect all available information and that price movements follow patterns that can be identified and exploited. The three main principles of technical analysis are: market action discounts everything, prices move in trends, and history tends to repeat itself. Chart patterns are visual representations of price movements that can help predict future price direction. Common patterns include head and shoulders, double tops and bottoms, triangles, flags, and pennants. These patterns are formed by the interaction between supply and demand forces in the market. Technical indicators are mathematical calculations based on price and volume data that provide additional insights into market behavior. Moving averages smooth out price data to identify trends, while oscillators like RSI and MACD help identify overbought and oversold conditions. Support and resistance levels are key price levels where buying or selling pressure is expected to emerge. Support levels act as floors where prices tend to bounce, while resistance levels act as ceilings where prices tend to reverse. Volume analysis confirms the strength of price movements and helps validate chart patterns and signals. Higher volume during breakouts and trend changes indicates stronger conviction among market participants. Time frame analysis is important for understanding the context of price movements. Longer time frames provide the overall trend direction, while shorter time frames help identify precise entry and exit points.
            """,
            "expected_compression": 0.35
        }
    ]
    
    compression_methods = ["extractive", "hybrid", "semantic"]
    target_ratios = [0.2, 0.3, 0.5]
    
    print(f"üìù Testing {len(sample_texts)} texts across {len(compression_methods)} methods and {len(target_ratios)} ratios...")
    print("-" * 60)
    
    total_tests = 0
    successful_tests = 0
    
    for text_data in sample_texts:
        print(f"\nüìÑ TEXT: {text_data['name']}")
        print(f"   Original length: {len(text_data['text'])} characters")
        print("-" * 40)
        
        for method in compression_methods:
            for ratio in target_ratios:
                print(f"\nüîß Method: {method}, Target ratio: {ratio}")
                
                try:
                    response = requests.post(
                        f"{base_url}/compress-context",
                        headers=headers,
                        data={
                            "text": text_data['text'],
                            "target_ratio": ratio,
                            "method": method,
                            "max_length": 1000
                        },
                        timeout=30
                    )
                    
                    if response.status_code == 200:
                        data = response.json()
                        compressed_text = data.get('compressed_text', '')
                        summary = data.get('summary', '')
                        key_points = data.get('key_points', [])
                        compression_ratio = data.get('compression_ratio', 0)
                        quality_score = data.get('quality_score', 0)
                        stats = data.get('stats', {})
                        
                        print(f"   ‚úÖ Success: {len(compressed_text)} chars ({compression_ratio:.2f} ratio)")
                        print(f"   üìä Quality score: {quality_score:.2f}")
                        print(f"   üìù Summary: {summary[:100]}...")
                        print(f"   üîë Key points: {len(key_points)}")
                        
                        # Show key points
                        if key_points:
                            print(f"   üìã Top key points:")
                            for i, point in enumerate(key_points[:3], 1):
                                print(f"      {i}. {point[:60]}...")
                        
                        # Check if compression target was met
                        if compression_ratio <= ratio + 0.1:  # Allow 10% tolerance
                            print(f"   ‚úÖ Compression target met!")
                        else:
                            print(f"   ‚ö†Ô∏è  Compression target not met (got {compression_ratio:.2f}, wanted {ratio:.2f})")
                        
                        successful_tests += 1
                    else:
                        print(f"   ‚ùå Error: HTTP {response.status_code}")
                        print(f"   Response: {response.text[:200]}")
                    
                    total_tests += 1
                    
                except Exception as e:
                    print(f"   ‚ùå Exception: {e}")
                    total_tests += 1
    
    print(f"\nüìä CONTEXT COMPRESSION SUMMARY")
    print("=" * 60)
    print(f"Total tests: {total_tests}")
    print(f"Successful: {successful_tests}")
    print(f"Failed: {total_tests - successful_tests}")
    print(f"Success rate: {(successful_tests/total_tests)*100:.1f}%")
    
    # Test compression effectiveness
    print(f"\nüî¨ COMPRESSION EFFECTIVENESS ANALYSIS")
    print("-" * 60)
    
    # Test with a specific text to see compression differences
    test_text = sample_texts[0]['text']
    print(f"üîç Test text: {sample_texts[0]['name']}")
    print(f"   Original length: {len(test_text)} characters")
    
    for method in compression_methods:
        try:
            response = requests.post(
                f"{base_url}/compress-context",
                headers=headers,
                data={
                    "text": test_text,
                    "target_ratio": 0.3,
                    "method": method,
                    "max_length": 1000
                },
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                compressed_text = data.get('compressed_text', '')
                compression_ratio = data.get('compression_ratio', 0)
                quality_score = data.get('quality_score', 0)
                
                print(f"\n   {method.capitalize()} Method:")
                print(f"      Compressed length: {len(compressed_text)} chars")
                print(f"      Compression ratio: {compression_ratio:.2f}")
                print(f"      Quality score: {quality_score:.2f}")
                print(f"      Preview: {compressed_text[:100]}...")
                
        except Exception as e:
            print(f"   {method.capitalize()}: Error - {e}")
    
    print(f"\nüéØ COMPRESSION FEATURES TESTED:")
    print("   ‚úÖ Multiple compression methods (extractive, hybrid, semantic)")
    print("   ‚úÖ Configurable target compression ratios")
    print("   ‚úÖ Quality scoring and preservation metrics")
    print("   ‚úÖ Key point extraction and summarization")
    print("   ‚úÖ Trading-specific content optimization")
    print("   ‚úÖ Performance tracking and statistics")
    print("   ‚úÖ Metadata and method information")
    
    print(f"\n‚è∞ Test completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    test_context_compression()